#本节课内容：

## REUSEADDR
- 可以使得不必等待TIME_WAIT状态消失就建立连接
- 服务端应尽量开启这个选项
```
int on = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))
```

## 处理多客户连接（process-per-connection）
- 父子进程之间的数据共享
    - 在linux下，内存存储的位置是全局变量，栈区，堆区，以及文件
    - 全局变量、栈区（局部变量）、堆区（动态分配）：不共享数据
    - 文件：共享文件描述符与偏移量
- close()函数
    - 使用close中止一个连接，它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。调用close后，将中止通信、删除套接字、丢弃数据。但是，如果有多个进程共享一个套接字，这时出现前述的情况，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
    - 父进程fork出子进程后，文件描述符+1，file的引用计数+1。但父子进程独立运行后再打开的文件就不在共享file对象，这个两个独立进程打开文件情况一样。父子进程传递文件描述符和两独立进程传递描述符性质一样。
- 主动/被动套接字
    - 服务器端套接字类型分为用于listen的被动套接字与accept建立连接后用于传输数据的主动套接字
    - 客户端只有主动套接字
- 父进程持续用于监听，有连接请求则创建一个子进程用于数据传输

## 点对点聊天程序的实现
- 服务端创建一个进程，主进程用于数据接受，子进程用于数据发送
- 客户端，父进程接收，子进程发送
    - 通过信号实现进程间通信，让父进程退出时通知子进程退出